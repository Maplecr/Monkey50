# 内核与进程模型总结

核心思考的问题是：

现代操作系统的目的，是多任务分享硬件，共享OS，并保证多个程序之间，程序和OS 之间相互隔离，必要时也可相互协作。

如何共享硬件（CPU，内存，外存，IO 端口）？如何共享软件（OS，库）？

如何实现隔离（CPU，内存，外存，IO 端口）？如何实现软件隔离？（A 任务用的 OS 和 B 任务用的 OS 隔离？）

如何实现协作？任务和任务之间的协作，任务和内核之间的协作（任务到内核，内核到任务，任务到任务）

 

# 目录

1、单 CPU 模式单任务单函数

2、单 CPU 模式单任务多函数

3、单 CPU 模式多（线程）任务

4、双 CPU 模式单进程空间

5、双 CPU 模式单进程空间单线程

6、双 CPU 模式单进程空间多线程

7、双 CPU 模式多进程空间

8、进程间通信与同步

9、调度和死锁

10、内存管理



```
*OS* 要管理程序的运行，需要知道程序运行过程中在 *CPU*（寄存器）、内存以及 *IO* 端口中可
能存在的中间状态数据（上下文）。因此，首先需要理解 *8086CPU* 机器上一个程序（一个程序， 是比较笼统的概念，通常指一个可执行文件内的代码和数据的集合，最简单可理解成一个代码段、一个数据段）在计算机内的运行过程，这样才能知道可能会有哪些中间状态出现。

为便于理解和讲述，一个程序的代码段是由一个或多个函数组成的。
```


一、单 **CPU** 模式单任务单函数

通过典型 CPU 指令的运行过程理解 CPU 寄存器、内存地址和 IO 端口的相互作用关系。

1.   （访存、IO 及异常指令的运行过程）首先假设内存里加载了一个代码段只有一个函数的程序（当然也有数据段）。这里请根据 8086CPU 解释：

a)    CPU 的通用寄存器有哪些？段的概念和 CS、DS、SS 的作用如何？CPU 是如何从内存取到指令的？CS、IP（汇编语言书第 2 章）


b)    假设 a)取到的是 MOV 指令，如何在寄存器到寄存器，寄存器到内存，内存到寄存器之间“复制”数据？能否实现内存到内存的数据“复制“？包括总线、寻址方式的概  念（汇编语言书第 3 章）


c)    程序地址、物理地址、链接的概念。（汇编语言书第 4、6 章）


d)    假设 a)取到的是 IN、OUT 指令，请解释能实现哪些功能？包括端口和控制器的概念。（汇编语言第 12－15 章）


e)    假设 a)取到的是 INT 指令，请解释异常、中断的概念及其作用。（汇编语言第 12－ 15 章）


二、单 **CPU** 模式单任务多函数

理解函数与函数的作用过程及栈的作用。

2.   （函数调函数的过程及栈变化）假设内存加载了一个有两个函数的程序，一个是主函数A，它会 call 另一个函数 B，请解释调用和被调用函数间，是如何实现参数传递的？另外，栈里面还存储哪些内容呢？被调函数 B 运行完成后，是如何返回到函数 A 中的？

（汇编语言书第 9、10 章）

**a)    call XXX XXX 是指什么？ call 和 jmp 的区别是什么？**

**b)    栈及栈帧用哪几个寄存器表示？SS：SP  SS：BP（汇编语言书第 10 章）SS:SP SS:BP**

**c)    尝试描述调用过程中栈的变化过程。（汇编语言书第 10 章）**


3.   （函数中产生的异常的处理及相应的栈的变化过程）假设内存加载了一个有两个函数的



4.   （函数运行中发生硬件中断的处理及其相应的栈的变化过程）假设内存加载了一个有两个函数的程序，一个是主函数 A，另一个是键盘中断函数 B，请解释主函数 A 和中断处理函数 B 之间，能实现参数传递的吗？如何实现？另外，两个函数共用一个栈可以吗？ 为什么？（汇编语言书第 14、15 章）



5.   （键盘中断驱动下的两函数交替运行）假设内存加载了一个有三个函数的程序，分别是函数 A、B，还有一个是键盘中断函数 C，键盘按下 A 时，运行函数 A，键盘按下 B 时， 运行函数 B。请描述如何实现这一功能？假设键盘按得慢，每次运行 A 或 B 时不会被下一次按键打断。三个函数共用一个栈可以吗？为什么？需要至少需要几个栈？每个函数用一个栈可以吗？为什么？

 

## 三、单 **CPU** 模式多（线程）任务

```
理解函数作为线程运行的过程，线程的创建、中止及切换。
```
6.   （时钟中断驱动下的两函数交叉运行）假设内存加载了一个有三个函数的程序，分别是函数 A、B（每个可至少运行 100 秒以上），还有一个是时钟中断处理函数 C，硬件时钟每毫秒产生一次中断，中断处理函数 C 返回时，轮流切换函数 A、B 的运行。请描述， 如何实现这一功能？三个函数共用一个栈可以吗？为什么？需要至少需要几个栈？每个函数用一个栈可以吗？为什么？



7.   （两函数的运行切换）上面第 6 题中，C 函数需要知道函数 A、B 的入口地址或上次停止的地址，它怎么知道呢？尝试描述一下，如何表示这些信息。并描述一下假如函数 A 运行过程中发生中断，运行 C，然后切换到函数 B 的运行过程。特别是这个过程栈的切换，以及各栈里面栈帧的变化情况。



8.   （线程的概念）你觉得第 6、7 中的两个函数 A、B 能够轮流运行，它们是两个线程吗？ 为什么？尝试描述一下你所理解的线程的概念是什么。





9.   有了线程的概念后，我们就有需要把 D 函数、E 函数等也创建成线程。要把一个普通函数创建成线程，需要做哪些事情呢？ TCB 有哪些内容？尝试描述并实现一个create_thread?



10. 如果想终止一个线程，需要做哪些事情呢？尝试描述并实现一个 cancel_thread?






11. 如果我们有一个线程 A（函数 A）和线程 B（函数 B）的协作需求：

a)    必须在 A 执行过 A 函数的 S1 语句后，B 才能执行 B 函数的 S2 语句，这就是同步。实现同步，实际上就是当运行到 S2 时检查一下 S1 运行过没有；如果运行过了，就继续，如果没有，就阻塞住线程 B 的运行。阻塞的方式有两种，一种是让它空转并所得查看 S1，一种是让它睡眠等待 S1 执行过后的唤醒。
b)    线程 A 和线程 B 会共享一个变量 t，如果 A 正在改写 t 时，B 试图读 t，读到的结果因对内存变量的交叉存取会不同。试解释交叉存取的概念。在程序中创建临界区是解决交叉存取问题的解决方案。如何构建一个临界区呢？构建的临界区要满足哪三个条件，才算成功？





12. 描述锁、关中断、互斥量、信号量、条件变量等概念及其实现。


```
目前为止，每个线程都可以调用 *create_thread* 创建线程，每个线程都可以直接 *IO* 操作， 都可以设置时钟中断的时长，如果它恶意修改了中断处理函数，或者修改了用来决定切换顺序的数据结构，那么都会影响到整个系统的运行。这时候，程序空间就是物理空间。


把开关中断，*IO* 指令、时钟周期的设置等等涉及到整个计算机系统运行情况的 *CPU* 指令作为特权指令，只让服务于整个系统的函数才能使用，其他普通线程函数都不能使用这些特权指令。这种把 *CPU* 设计成两种运行模式（系统模式和用户模式）的方式，叫做 *CPU* 的双（运行）模式，简称双模式。系统模式下能够运行 *CPU* 所有指令；用户模式下，只能够运行特权指令之外的普通 *CPU* 指令。

在 *CPU* 双模式下，把创建线程、中止线程，创建信号量、*PV* 操作、开关中断，*IO* 指令、异常和中断处理函数等涉及到多个线程和整个系统运行情况的函数，作为 *OS* 的雏形，运行在*CPU* 的系统模式，而普通线程的函数则运行在 *CPU* 的用户模式。

在内存管理上，也划分为内核内存空间，和用户内存空间。作为 *OS* 雏形的部分，比如 *C*函数，放置在内核空间，作为多线程的 *A*、*B* 函数，则放置在用户空间。
```


## 四、双 **CPU** 模式单进程空间
```
理解进程空间由用户空间和内核空间组成。理解基于 386 如何搭建出一个进程空间。用户程序通过分段到线性空间的用户空间部分，内核程序通过分段映射到线性空间的内核空间部分。在只有分段的情况下，线性空间就是物理空间。
```



13. 在 386 启动过程中，将 CR0 寄存器的保护模式位置位，也就是启用保护模式，使 386CPU具备了 0‐3 四个运行级别。操作系统里说的 CPU 双模式，指的是 386 里的 0 和 3 两个运行级别。0 级别是系统模式，3 级别是用户模式。请说说 386 设置 4 个运行级别的目的是什么？为什么操作系统只用了两个运行级别（双模式）？

14. 分段的作用，是通过段表，把一个程序中的多个段映射到一维的线性空间（4GB）。为便于理解，本部分下面的几个问题都假设计算机正好也有 4GB 的物理内存，这样 4GB 的线性空间正好能一对一装载到物理空间。因此可假设线性空间就是物理空间。

15. CS：EIP 是 386CPU 给出的 PC（程序计数器），DS：EXX 是数据地址，SS：ESP 是栈地址，SS：EBP 是栈帧地址。试描述一下 CS、DS、SS 和 GDTR、LDTR 的关系。GDT、LDT 里面存储的都是段描述符，有什么区别吗？

16. 现在假设一个执行文件里保存了内核的代码段和数据段，一个执行文件里保存了用户空间的代码段和数据段。我们直接把这四个段装载到物理内存，可能会存在什么问题？





17. 还是假设第 16 题中的两个可执行文件，我们想把内核的段映射到内核空间（CPL、DPL 为 0），把用户的段映射到用户空间（CPL、DPL 为 3），直接在 GDT 里创建四段描述符，可以吗？或者在 GDT 里创建内核两个段的描述符和一个 LDT 的描述符；然后在 LDT 里创建两个用户段的描述符，也是一种方案。这两种方案各有什么优缺点？





18. 当然，为了让内核空间的程序和用户空间的程序能够运行，我们需要分别在内核空间和用户空间各创建一个栈段，也就是要在 GDT、LDT 增加两个栈的段描述符。试基于 17 题里的两种方案分别讲讲在哪里增加这两个段描述符。


```
有了 *386* 的 *0*，*3* 运行级别，以及 *GDT* 和 *LDT* 的初始化后。下面我们再回头看看第二部分和第三部分的各题目的故事，有了哪些变化。
```


## 五、双 **CPU** 模式单进程空间单线程
```
理解一个进程程序运行过程中，CPU 在用户模式和内核模式来回切换，相应的内存也在用户空间和内核空间的来回切换。
```

19. 第二部分第 2 题（简写为“二 2”题，以下所有题号简写类似），有了两个可能，在用户空间的函数调用函数，使用用户空间的栈，在内核空间的函数调用函数，使用内核空间的栈。



20. 第二 3 题，在用户空间执行 INT 0x80 指令时，会引发 CPU 从运行级别 3 到运行级别 0 的切换，同时也会发生栈的切换。CPU 具体做了哪些事情？请参考 386 手册。在系统启动时，有对 IDT 中有针对 0x80 的初始化，初始化的那个地址指向的就是系统调用的总入口函数。这也是系统调用的实现原理。请简述系统调用的概念及在 386 上的实现方法。

21. 第二 4 题，用户空间的函数 A 在运行过程中，发生了硬件中断，描述中断发生后，CPU 运行级别、内存空间以及栈的切换过程。请参考 386 手册。

22. 第二 5 题，可以把函数 A、B 理解成位于用户空间，通过内核空间的中断处理函数，来帮助切换用户空间两个函数的交替运行。为第三 6 题理解纯用户线程做准备。

23. 当然，第二 5 题，也可以把函数 A、B 理解成位于内核空间，也就是他们是 OS 的函数。来理解纯内核线程的概念。

 

## 六、双 **CPU** 模式单进程空间多线程
```
理解纯用户线程，纯内核线程，线程模型。
```


24. 根据三 6——三 7 题，假设函数 A、B 位于内核空间，也就是要把函数 A、B 创建成两个纯内核线程，尝试描述它们的 TCB 及时钟中断驱动下的任务切换过程。

25. 根据三 8——三 10 题，要把内核空间的函数 A、B 创建成纯内核线程，需要设计的 TCB

应包括哪些内容？创建和中止纯内核线程的函数如何实现？

26. 假设题 24、25 把函数 A、B 位于用户空间，也就是要把函数 A、B 创建成两个纯用户线程，尝试设计 TCB 及相应的创建、中止及调度函数。

27. 在题 26 中，纯用户线程的 TCB 位于用户空间，使用用户空间的栈运行，创设 A 用户线程运行过程中，调用 read 系统调用，调用过程中因为磁盘忙面阻塞。而后运行到了 B 用户线程，而 B 线程在运行过程中，需要调用 write 系统调用。请问这时的 B 线程能做write 系统调用吗？为什么？（考虑系统调用进入内核后使用哪个内核栈）

28. 怎样才能解决题 27 中 B 线程不能再做系统调用的问题呢？尝试描述各种不同线程模型的解决方案间的异同及其优缺点。

29. 对比 Linux 和 Windows 的线程模型。

 

```
第四、五部分的题目，假设线性空间就是物理空间，这导致一个计算机的物理内存，只能放一个线性空间（进程）。如何能在一个计算机的物理内存中，放入多个程序（进程）的线程空间呢？把线性空间分页，通过页表映射到物理内存，是一种解决方案。也就是使用分段*+*分页的内存管理方案。
```
```
说明：*Linux0.11* 是把多程序（进程）和内核的空间全部映射到了一个线程空间，但现代 *OS* 一般把一个程序的空间和内核的空间合在一起映射成一个线性空间，也就是在这种情况下，线性空间就是进程空间。
```


## 七、双 **CPU** 模式多进程空间
```
理解进程的表示及进程的创建、切换与中止。
```
30. 如何把 OS 内核，多个用户程序，映射到同一个物理（内存）空间，还做到相互隔离呢？ 一种办法是，参考题 17 的第一种方法，只用 GDT，把内核和多个程序，都映射到一个线性空间，这样的好处和缺点分别是什么？

31. 再一种办法是，参考题 17 的第二种办法，用 GDT 映射内核空间，并存放 LDT 的描述符， 用 LDT 映射用户空间，但内核和程序都映射到同一个线性空间，线性空间就是物理空间。也就是这里没有使用分页机制。比较这个方案和题 30 方案的优缺点。

32. 题 31 的方案，也可把线性空间分页，通过两级页表映射到物理空间。这样做的好处是， 物理内存就可按页为单位管理，比按段为单位管理方便有效多了。为什么？0.11 采用的是这种方案。

33. 现代 OS 一般把一个用户程序和内核合在一起单独映射成一个线性空间（称为进程空间）。再把线性空间分页，再通过页表映射到物理内存。这样一是进程有了更大的独立空间， 二是题 32 的物理内存管理的优点也具备了。当然也有缺点，就是切换进程是要切换页目录的，所以设置了 CR3 寄存器，但不能避免所有 TLB 和 cache 会失效带来的开销。

34. 基于题 33，把用户程序空间和内核空间映射到一个线性空间，如果提前规定好内核和用户程序使用哪部分的线性空间，就可在链接的时候，由链接器直接生成线性地址。也就是在链接时，就把内核和用户程序的各个段都映射到线性空间（进程空间）了。这一点等同于 Intel386 的平面地址的想法。因此，实际上在一个程序运行前，要代表它运行的进程的分段映射就已经完成了，等到内存实际运行时，只需要分页就可以了。因此 ARM 等新型的 CPU，一般都只能支持分段和分页机制中的一种，不用像 386 这样分段+分页。

35. 基于题 34，因为 386 在启用分页机制前，必须启用分段机制，所以可考虑利用其平面地址的分段映射方式（实际上相当于没有使用分段的地址映射，但使用了分段机制的权限检查，这样能保证用户的代码段不能访问到内核空间的代码和数据段），基于分页机制实现多个线性空间到一个物理空间的映射。

36. 当系统内有多个程序和一个内核同时存在时，如何区分并表示这些运行中的程序，即进程呢？也就是 PCB 中应该有哪些数据项呢？参考现代操作系统的图示、Linux 的task_struct、0.11 的 task_struct+TSS（为什么要考虑 TSS？）。

37. 参考 Linux2.6 以上的 task_struct, （进程那章课件里有），解释什么是轻量级进程，为什么叫轻量级呢？线程是不是轻量级进程，为什么？

38. 在三 6、三 7 题的基础上，结合题 32、36，对比进程切换和线程切换的联系与区别。

 

## 八、进程间通信与同步
```
在进程空间相互独立后，进程间相互的协作可分为三类：1 是传递数据，2 是同步，3 是互斥访问共享数据。
```
39. 能够用在进程间实现数据通信和同步的工具包括：共享内存、消息队列、信号量等。管道、socket、普通文件也是进程间进行数据传递的可选方式。能够用在进程之间通信和   同步的工具，是需要在内核实现的。

40. 信号是内核与用户程序之间，不同进程用户程序之间沟通的一种异步机制。通常其实现方式直接包含在进程概念中，因此是 UNIX 操作系统一种基础机制。

41. 联系题 11，生产者——消费者问题，读者——写者问题、哲学家就餐问题，应该能通过选用以上合适的同步工具，基于多进程或多线程的方式，实现相应的应用程序。

42. 对锁、信号量、管程，应掌握概念并理解实现方式。

43. 对信号和管道，可尝试理解其实现方式。管道以文件形式实现，在学习文件系统后，可尝试理解。

 

## 九、调度和死锁
```
针对不同适用领域的 OS，会有不同的调度设计指标。调度不好，会死锁。要预防和避免。
```
44. 抢占式、非抢占式调度的概念。

45. 调度算法的评估标准有哪些？理解调度算法的评估方法。

46. Linux、Window 实际使用的一些调度算法。

47. 死锁的概念，死锁发生的四个充要条件。死锁的预防、避免、检测与恢复方法。




## 十、内存管理
```
理解现代 OS 进程空间按需分配、物理内存按供分配、关键数据结构建立缓存池的指导思想。
```
48. 理解程序运行的局部性原理。

49. 完整地理解虚拟内存的概念，即利用外存做内存。理解可执行文件的格式（如 ELF）。

50. 请求调页与缺页中断的概念、实现方法与运行过程。交换空间的概念、页替换算法，以及交换过程。工作集和系统颠簸的概念，系统互锁的概念。

51. 解释空闲物理内存页的管理（分配和回收）方式。

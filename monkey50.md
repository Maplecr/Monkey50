# 作业 06 内核与进程模型总结

 

本次作业 12 月 8 日与实验 07 的实验报告同时交。具体交的方式要符合助教要求。每位同学基础不同，完成理解所需要的时间和付出的时间和努力也会大有不同。有困难可向助教申请延迟提交。

本文档的目标，试图从内存中只有一个函数说起，逐步增加功能，在基于硬件功能的基础上，构建出一个现代 OS 的进程框架。

每位同学可从前向后逐题思考解答。不会的需要弄明白后再转向下一题。我们采用的策略是，优先解决一些进展好同学的问题，让他们先懂，再让他们培养进展中等的，依次实现分层级的帮带。

因为逻辑复杂，时间仓促，部分表达语句可能不够清晰，甚至有误。大家有问题请及时在课程群里讨论。如果有困难，请联系助教或老师。

 

核心思考的问题是：

l 现代操作系统的目的，是多任务分享硬件，共享OS，并保证多个程序之间，程序和OS 之间相互隔离，必要时也可相互协作。

l 如何共享硬件（CPU，内存，外存，IO 端口）？如何共享软件（OS，库）？

l 如何实现隔离（CPU，内存，外存，IO 端口）？如何实现软件隔离？（A 任务用的 OS 和 B 任务用的 OS 隔离？）

l 如何实现协作？任务和任务之间的协作，任务和内核之间的协作（任务到内核，内核到任务，任务到任务）

 

# 目录

一、单 CPU 模式单任务单函数........................................................ 2

二、单 CPU 模式单任务多函数........................................................ 2

三、单 CPU 模式多（线程）任务.................................................... 3

四、双 CPU 模式单进程空间............................................................ 4

五、双 CPU 模式单进程空间单线程................................................. 5

六、双 CPU 模式单进程空间多线程................................................. 6

七、双 CPU 模式多进程空间............................................................ 7

[八、进程间通信与同步........................................................................ 8](#_TOC_250002)

[九、调度和死锁................................................................................... 8](#_TOC_250001)

[十、内存管理....................................................................................... 9](#_TOC_250000)


 

### *OS* 要管理程序的运行，需要知道程序运行过程中在 *CPU*（寄存器）、内存以及 *IO* 端口中可

能存在的中间状态数据（上下文）。因此，首先需要理解 *8086CPU* 机器上一个程序（一个程序， 是比较笼统的概念，通常指一个可执行文件内的代码和数据的集合，最简单可理解成一个代码段、一个数据段）在计算机内的运行过程，这样才能知道可能会有哪些中间状态出现。

为便于理解和讲述，一个程序的代码段是由一个或多个函数组成的。

 

一、单 **CPU** 模式单任务单函数

通过典型 CPU 指令的运行过程理解 CPU 寄存器、内存地址和 IO 端口的相互作用关系。

\1.   （访存、IO 及异常指令的运行过程）首先假设内存里加载了一个代码段只有一个函数的程序（当然也有数据段）。这里请根据 8086CPU 解释：

a)    CPU 的通用寄存器有哪些？段的概念和 CS、DS、SS 的作用如何？CPU 是如何从内存取到指令的？CS、IP（汇编语言书第 2 章）

CPU的通用寄存器有四个，分别为AX,BX,CX,DX，通常用来存放一般性的数据。

其实内存并没有分段，段的划分来自于CPU，由于8086CPU用“基础地址(段地址*16)+偏移地址=物理地址”给出内存单元物理地址，我们可以使用分段的方式管理内存。

CS(Code Segment)是8086CPU中比较关键的寄存器，常与IP(Integer Point)寄存器一起使用，任意时刻，CPU将CS:IP指向的内容当作指令执行。

CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成，DS寄存器就是用来存放需要访问的数据段地址。

现今的CPU都有栈的设计，8086CPU不例外，8086CPU提供相关指令来以栈的方式访问内存空间。这样也需要一个寄存器存放栈顶的地址。栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素。

程序员通过改变CS,IP的内容控制CPU执行目标指令。可用指令“jmp 段地址：偏移地址”实现从内存中读取指令。

b)    假设 a)取到的是 MOV 指令，如何在寄存器到寄存器，寄存器到内存，内存到寄存器之间“复制”数据？能否实现内存到内存的数据“复制“？包括总线、寻址方式的概  念（汇编语言书第 3 章）

MOV指令有以下几种形式

mov 寄存器，数据

mov 寄存器, 寄存器

mov 寄存器, 内存单元

mov 内存单元, 寄存器

mov 段寄存器, 寄存器

不能实现，需要一个中间寄存器进行转移。

总线:是计算机各个功能部件之间传输信息的公共信息干线，总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。其是一种内部结构，是CPU、内存、输入输出传递信息的公用通道。

寻址方式：处理器根据指令中给出地址信息来寻找有效地址的方式，是确定本条指令的数据地址以及下一条要执行的指令地址的方法。

c)    程序地址、物理地址、链接的概念。（汇编语言书第 4、6 章）

程序的地址空间：并不是真正的物理内存，只是进程的一个地址空间。其本质是一个描述地址分配的结构体，并且是一个虚拟地址，两个进程可能有相同的一个地址。出现进程地址相当于PCB+地址空间+映射空间

物理地址：是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址就直接成为物理地址了。

链接：这个是汇编语言中的概念，gcc会到默认的搜索路径“/usr/lib”下进行查找，并链接到libc.so.6库函数中，函数库分为一般库和动态库两种。静态库指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的的文件比较大，但在运行时也就不需要库文件了；动态库相反，编译链接的时候并没有把库文件放入可执行文件中，而是程序执行的时候运行链接文件加载库，这样可以节省系统的开销。gcc编译的时候默认使用动态库。

d)    假设 a)取到的是 IN、OUT 指令，请解释能实现哪些功能？包括端口和控制器的概念。（汇编语言第 12－15 章）

汇编语言中，CPU对外设的操作通过专门的端口读写指令来完成，读端口使用IN指令，写端口使用OUT指令。

端口是主机与外设进行数据交换使用的，分为数据端口、状态端口和控制端口三种。CPU把三大主要总线当作内存看待，除了各种存储器之外，还与很多芯片相连。这些芯片中都有一组可以由CPU读写的寄存器，CPU把这些寄存器当做端口，对他们进行统一编址，并建立一个统一的端口地址空间。

CPU中的控制器？？？？

e)    假设 a)取到的是 INT 指令，请解释异常、中断的概念及其作用。（汇编语言第 12－ 15 章）

异常也称为内中断、例外或陷入，指源自CPU执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出、虚存系统的却也以及专门的陷入指令等引起的事件。

中断也称为外中断，指来自CPU执行指令以外的事件发生，如设备发出的I/O结束中断，表示设备的输入输出以及完成，希望处理机能够向设备发下一个输入输出的请求，同时让完成I/O的程序继续运行，时钟中断，表示一个固定的时间片已到，让处理器处理计时、启动定时运行的任务等。

二、单 **CPU** 模式单任务多函数

理解函数与函数的作用过程及栈的作用。

\2.   （函数调函数的过程及栈变化）假设内存加载了一个有两个函数的程序，一个是主函数A，它会 call 另一个函数 B，请解释调用和被调用函数间，是如何实现参数传递的？另外，栈里面还存储哪些内容呢？被调函数 B 运行完成后，是如何返回到函数 A 中的？

（汇编语言书第 9、10 章）

a)    call XXX XXX 是指什么？ call 和 jmp 的区别是什么？

CPU执行CALL指令的时候，进行两步操作，将当前的IP或CS和IP压入栈中，转移。

call指令转移不能实现段转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。

jmp指令为无条件转移指令，可以修改IP，也可以同时修改CS和IP

b)    栈及栈帧用哪几个寄存器表示？SS：SP  SS：BP（汇编语言书第 10 章）

SS:SP SS:BP

c)    尝试描述调用过程中栈的变化过程。（汇编语言书第 10 章）

主要是四个过程

\1.  压栈: 函数参数压栈，返回地址压栈

\2.  跳转: 跳转到函数所在代码处执行

\3.  执行: 执行函数代码

\4.  返回: 平衡堆栈，找出之前的返回地址，跳转回之前的调用点之后，完成函数调用

 


 

\3.   （函数中产生的异常的处理及相应的栈的变化过程）假设内存加载了一个有两个函数的

程序，一个是主函数 A，另一个是异常处理函数 B。A 会通过 INT 指令，激活异常处理函数 B 的执行，请解释主函数 A 和异常处理函数 B 间，能实现参数传递的吗？如何实现？ 另外，两个函数共用一个栈可以吗？为什么？（汇编语言书第 12、13 章）

？？？

\4.   （函数运行中发生硬件中断的处理及其相应的栈的变化过程）假设内存加载了一个有两个函数的程序，一个是主函数 A，另一个是键盘中断函数 B，请解释主函数 A 和中断处理函数 B 之间，能实现参数传递的吗？如何实现？另外，两个函数共用一个栈可以吗？ 为什么？（汇编语言书第 14、15 章）

\5.   （键盘中断驱动下的两函数交替运行）假设内存加载了一个有三个函数的程序，分别是函数 A、B，还有一个是键盘中断函数 C，键盘按下 A 时，运行函数 A，键盘按下 B 时， 运行函数 B。请描述如何实现这一功能？假设键盘按得慢，每次运行 A 或 B 时不会被下一次按键打断。三个函数共用一个栈可以吗？为什么？需要至少需要几个栈？每个函数用一个栈可以吗？为什么？

 

三、单 **CPU** 模式多（线程）任务

理解函数作为线程运行的过程，线程的创建、中止及切换。

\6.   （时钟中断驱动下的两函数交叉运行）假设内存加载了一个有三个函数的程序，分别是函数 A、B（每个可至少运行 100 秒以上），还有一个是时钟中断处理函数 C，硬件时钟每毫秒产生一次中断，中断处理函数 C 返回时，轮流切换函数 A、B 的运行。请描述， 如何实现这一功能？三个函数共用一个栈可以吗？为什么？需要至少需要几个栈？每个函数用一个栈可以吗？为什么？

\7.   （两函数的运行切换）上面第 6 题中，C 函数需要知道函数 A、B 的入口地址或上次停止的地址，它怎么知道呢？尝试描述一下，如何表示这些信息。并描述一下假如函数 A 运行过程中发生中断，运行 C，然后切换到函数 B 的运行过程。特别是这个过程栈的切换，以及各栈里面栈帧的变化情况。

\8.   （线程的概念）你觉得第 6、7 中的两个函数 A、B 能够轮流运行，它们是两个线程吗？ 为什么？尝试描述一下你所理解的线程的概念是什么。

\9.   有了线程的概念后，我们就有需要把 D 函数、E 函数等也创建成线程。要把一个普通函数创建成线程，需要做哪些事情呢？ TCB 有哪些内容？尝试描述并实现一个

create_thread?


 

\10. 如果想终止一个线程，需要做哪些事情呢？尝试描述并实现一个 cancel_thread?

 在一个线程中return

 exit

\11. 如果我们有一个线程 A（函数 A）和线程 B（函数 B）的协作需求：

a)    必须在 A 执行过 A 函数的 S1 语句后，B 才能执行 B 函数的 S2 语句，这就是同步。实现同步，实际上就是当运行到 S2 时检查一下 S1 运行过没有；如果运行过了，就继续，如果没有，就阻塞住线程 B 的运行。阻塞的方式有两种，一种是让它空转并所得查看 S1，一种是让它睡眠等待 S1 执行过后的唤醒。

b)    线程 A 和线程 B 会共享一个变量 t，如果 A 正在改写 t 时，B 试图读 t，读到的结果因对内存变量的交叉存取会不同。试解释交叉存取的概念。在程序中创建临界区是解决交叉存取问题的解决方案。如何构建一个临界区呢？构建的临界区要满足哪三个条件，才算成功？



\12. 描述锁、关中断、互斥量、信号量、条件变量等概念及其实现。

锁可以理解为内存中的一个整型数，拥有两种状态：空闲状态和上锁状态，加锁时判断锁是否空闲，如果空闲修改为上锁状态，返回成功。如果已经上锁，则返回失败。解锁的时候，则把锁的状态改为空闲状态。

 

关中断、即禁止中断是指禁止中断出现或禁止相应中断的指令。可分为特权指令和软中断指令。

 

互斥锁是一种用于多线程编程中，防止两条线程同时对一个公共资源进行读写的机制。

 

信号量被定义是一个整型变量，除初始化之外，仅能通过两个标准源自操作Wait(S)和Signal(S)来访问，分别被称为P,V操作。

   

   条件变量(cond)是在多线程程序中用来实现"等待--》唤醒"逻辑常用的方法。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使“条件成立”。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。线程在改变条件状态前必须首先锁住互斥量，函数pthread_cond_wait把自己放到等待条件的线程列表上，然后对互斥锁解锁(这两个操作是原子操作)。在函数返回时，互斥量再次被锁住。

 

 

###  

###  

###  

### 目前为止，每个线程都可以调用 *create_thread* 创建线程，每个线程都可以直接 *IO* 操作， 都可以设置时钟中断的时长，如果它恶意修改了中断处理函数，或者修改了用来决定切换顺序的数据结构，那么都会影响到整个系统的运行。这时候，程序空间就是物理空间。

把开关中断，*IO* 指令、时钟周期的设置等等涉及到整个计算机系统运行情况的 *CPU* 指令作为特权指令，只让服务于整个系统的函数才能使用，其他普通线程函数都不能使用这些特权指令。这种把 *CPU* 设计成两种运行模式（系统模式和用户模式）的方式，叫做 *CPU* 的双（运行）模式，简称双模式。系统模式下能够运行 *CPU* 所有指令；用户模式下，只能够运行特权指令之外的普通 *CPU* 指令。

在 *CPU* 双模式下，把创建线程、中止线程，创建信号量、*PV* 操作、开关中断，*IO* 指令、异常和中断处理函数等涉及到多个线程和整个系统运行情况的函数，作为 *OS* 的雏形，运行在*CPU* 的系统模式，而普通线程的函数则运行在 *CPU* 的用户模式。

在内存管理上，也划分为内核内存空间，和用户内存空间。作为 *OS* 雏形的部分，比如 *C*函数，放置在内核空间，作为多线程的 *A*、*B* 函数，则放置在用户空间。

 

四、双 **CPU** 模式单进程空间

理解进程空间由用户空间和内核空间组成。理解基于 386 如何搭建出一个进程空间。用户程序通过分段到线性空间的用户空间部分，内核程序通过分段映射到线性空间的内核空间部分。在只有分段的情况下，线性空间就是物理空间。


 

\13. 在 386 启动过程中，将 CR0 寄存器的保护模式位置位，也就是启用保护模式，使 386CPU

具备了 0‐3 四个运行级别。操作系统里说的 CPU 双模式，指的是 386 里的 0 和 3 两个运行级别。0 级别是系统模式，3 级别是用户模式。请说说 386 设置 4 个运行级别的目的是什么？为什么操作系统只用了两个运行级别（双模式）？

\14. 分段的作用，是通过段表，把一个程序中的多个段映射到一维的线性空间（4GB）。为便于理解，本部分下面的几个问题都假设计算机正好也有 4GB 的物理内存，这样 4GB 的线性空间正好能一对一装载到物理空间。因此可假设线性空间就是物理空间。

\15. CS：EIP 是 386CPU 给出的 PC（程序计数器），DS：EXX 是数据地址，SS：ESP 是栈地址，

SS：EBP 是栈帧地址。试描述一下 CS、DS、SS 和 GDTR、LDTR 的关系。GDT、LDT 里面存储的都是段描述符，有什么区别吗？

\16. 现在假设一个执行文件里保存了内核的代码段和数据段，一个执行文件里保存了用户空间的代码段和数据段。我们直接把这四个段装载到物理内存，可能会存在什么问题？

\17. 还是假设第 16 题中的两个可执行文件，我们想把内核的段映射到内核空间（CPL、DPL 为 0），把用户的段映射到用户空间（CPL、DPL 为 3），直接在 GDT 里创建四段描述符，可以吗？或者在 GDT 里创建内核两个段的描述符和一个 LDT 的描述符；然后在 LDT 里创建两个用户段的描述符，也是一种方案。这两种方案各有什么优缺点？

\18. 当然，为了让内核空间的程序和用户空间的程序能够运行，我们需要分别在内核空间和用户空间各创建一个栈段，也就是要在 GDT、LDT 增加两个栈的段描述符。试基于 17 题里的两种方案分别讲讲在哪里增加这两个段描述符。

 

有了 *386* 的 *0*，*3* 运行级别，以及 *GDT* 和 *LDT* 的初始化后。下面我们再回头看看第二部分和第三部分的各题目的故事，有了哪些变化。

 

五、双 **CPU** 模式单进程空间单线程

理解一个进程程序运行过程中，CPU 在用户模式和内核模式来回切换，相应的内存也在用户空间和内核空间的来回切换。

 

\19. 第二部分第 2 题（简写为“二 2”题，以下所有题号简写类似），有了两个可能，在用户空间的函数调用函数，使用用户空间的栈，在内核空间的函数调用函数，使用内核空间的栈。


 

\20. 第二 3 题，在用户空间执行 INT 0x80 指令时，会引发 CPU 从运行级别 3 到运行级别 0 的

切换，同时也会发生栈的切换。CPU 具体做了哪些事情？请参考 386 手册。在系统启动时，有对 IDT 中有针对 0x80 的初始化，初始化的那个地址指向的就是系统调用的总入口函数。这也是系统调用的实现原理。请简述系统调用的概念及在 386 上的实现方法。

\21. 第二 4 题，用户空间的函数 A 在运行过程中，发生了硬件中断，描述中断发生后，CPU 运行级别、内存空间以及栈的切换过程。请参考 386 手册。

\22. 第二 5 题，可以把函数 A、B 理解成位于用户空间，通过内核空间的中断处理函数，来帮助切换用户空间两个函数的交替运行。为第三 6 题理解纯用户线程做准备。

\23. 当然，第二 5 题，也可以把函数 A、B 理解成位于内核空间，也就是他们是 OS 的函数。来理解纯内核线程的概念。

 

六、双 **CPU** 模式单进程空间多线程

理解纯用户线程，纯内核线程，线程模型。

 

\24. 根据三 6——三 7 题，假设函数 A、B 位于内核空间，也就是要把函数 A、B 创建成两个纯内核线程，尝试描述它们的 TCB 及时钟中断驱动下的任务切换过程。

\25. 根据三 8——三 10 题，要把内核空间的函数 A、B 创建成纯内核线程，需要设计的 TCB

应包括哪些内容？创建和中止纯内核线程的函数如何实现？

\26. 假设题 24、25 把函数 A、B 位于用户空间，也就是要把函数 A、B 创建成两个纯用户线程，尝试设计 TCB 及相应的创建、中止及调度函数。

\27. 在题 26 中，纯用户线程的 TCB 位于用户空间，使用用户空间的栈运行，创设 A 用户线程运行过程中，调用 read 系统调用，调用过程中因为磁盘忙面阻塞。而后运行到了 B 用户线程，而 B 线程在运行过程中，需要调用 write 系统调用。请问这时的 B 线程能做

write 系统调用吗？为什么？（考虑系统调用进入内核后使用哪个内核栈）

\28. 怎样才能解决题 27 中 B 线程不能再做系统调用的问题呢？尝试描述各种不同线程模型的解决方案间的异同及其优缺点。

\29. 对比 Linux 和 Windows 的线程模型。

 

### 第四、五部分的题目，假设线性空间就是物理空间，这导致一个计算机的物理内存，只能放一个线性空间（进程）。如何能在一个计算机的物理内存中，放入多个程序（进程）的线程空


 

间呢？把线性空间分页，通过页表映射到物理内存，是一种解决方案。也就是使用分段*+*分页

的内存管理方案。

说明：*Linux0.11* 是把多程序（进程）和内核的空间全部映射到了一个线程空间，但现代 *OS* 一般把一个程序的空间和内核的空间合在一起映射成一个线性空间，也就是在这种情况下，线性空间就是进程空间。

 

七、双 **CPU** 模式多进程空间

理解进程的表示及进程的创建、切换与中止。

\30. 如何把 OS 内核，多个用户程序，映射到同一个物理（内存）空间，还做到相互隔离呢？ 一种办法是，参考题 17 的第一种方法，只用 GDT，把内核和多个程序，都映射到一个线性空间，这样的好处和缺点分别是什么？

\31. 再一种办法是，参考题 17 的第二种办法，用 GDT 映射内核空间，并存放 LDT 的描述符， 用 LDT 映射用户空间，但内核和程序都映射到同一个线性空间，线性空间就是物理空间。也就是这里没有使用分页机制。比较这个方案和题 30 方案的优缺点。

\32. 题 31 的方案，也可把线性空间分页，通过两级页表映射到物理空间。这样做的好处是， 物理内存就可按页为单位管理，比按段为单位管理方便有效多了。为什么？0.11 采用的是这种方案。

\33. 现代 OS 一般把一个用户程序和内核合在一起单独映射成一个线性空间（称为进程空间）。再把线性空间分页，再通过页表映射到物理内存。这样一是进程有了更大的独立空间， 二是题 32 的物理内存管理的优点也具备了。当然也有缺点，就是切换进程是要切换页目录的，所以设置了 CR3 寄存器，但不能避免所有 TLB 和 cache 会失效带来的开销。

\34. 基于题 33，把用户程序空间和内核空间映射到一个线性空间，如果提前规定好内核和用户程序使用哪部分的线性空间，就可在链接的时候，由链接器直接生成线性地址。也就是在链接时，就把内核和用户程序的各个段都映射到线性空间（进程空间）了。这一点等同于 Intel386 的平面地址的想法。因此，实际上在一个程序运行前，要代表它运行的进程的分段映射就已经完成了，等到内存实际运行时，只需要分页就可以了。因此 ARM 等新型的 CPU，一般都只能支持分段和分页机制中的一种，不用像 386 这样分段+分页。

\35. 基于题 34，因为 386 在启用分页机制前，必须启用分段机制，所以可考虑利用其平面地址的分段映射方式（实际上相当于没有使用分段的地址映射，但使用了分段机制的权限检查，这样能保证用户的代码段不能访问到内核空间的代码和数据段），基于分页机制


 

实现多个线性空间到一个物理空间的映射。

\36. 当系统内有多个程序和一个内核同时存在时，如何区分并表示这些运行中的程序，即进程呢？也就是 PCB 中应该有哪些数据项呢？参考现代操作系统的图示、Linux 的

task_struct、0.11 的 task_struct+TSS（为什么要考虑 TSS？）。

\37. 参考 Linux2.6 以上的 task_struct, （进程那章课件里有），解释什么是轻量级进程，为什么叫轻量级呢？线程是不是轻量级进程，为什么？

\38. 在三 6、三 7 题的基础上，结合题 32、36，对比进程切换和线程切换的联系与区别。

 

## 八、进程间通信与同步

在进程空间相互独立后，进程间相互的协作可分为三类：1 是传递数据，2 是同步，3 是互斥访问共享数据。

\39. 能够用在进程间实现数据通信和同步的工具包括：共享内存、消息队列、信号量等。管道、socket、普通文件也是进程间进行数据传递的可选方式。能够用在进程之间通信和   同步的工具，是需要在内核实现的。

\40. 信号是内核与用户程序之间，不同进程用户程序之间沟通的一种异步机制。通常其实现方式直接包含在进程概念中，因此是 UNIX 操作系统一种基础机制。

\41. 联系题 11，生产者——消费者问题，读者——写者问题、哲学家就餐问题，应该能通过选用以上合适的同步工具，基于多进程或多线程的方式，实现相应的应用程序。

\42. 对锁、信号量、管程，应掌握概念并理解实现方式。

\43. 对信号和管道，可尝试理解其实现方式。管道以文件形式实现，在学习文件系统后，可尝试理解。

 

## 九、调度和死锁

针对不同适用领域的 OS，会有不同的调度设计指标。调度不好，会死锁。要预防和避免。

\44. 抢占式、非抢占式调度的概念。

\45. 调度算法的评估标准有哪些？理解调度算法的评估方法。

\46. Linux、Window 实际使用的一些调度算法。

\47. 死锁的概念，死锁发生的四个充要条件。死锁的预防、避免、检测与恢复方法。


 

## 十、内存管理

理解现代 OS 进程空间按需分配、物理内存按供分配、关键数据结构建立缓存池的指导思

想。

\48. 理解程序运行的局部性原理。

\49. 完整地理解虚拟内存的概念，即利用外存做内存。理解可执行文件的格式（如 ELF）。

\50. 请求调页与缺页中断的概念、实现方法与运行过程。交换空间的概念、页替换算法，以及交换过程。工作集和系统颠簸的概念，系统互锁的概念。

\51. 解释空闲物理内存页的管理（分配和回收）方式。
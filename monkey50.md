内核与进程模型总结
===

## 单CPU模式单任务单函数

### 1.（访存、IO及异常指令的运行过程）首先理解内存加载一个只有一个函数的程序，当然也有代码段和数据段。这里请根据8086CPU解释：

#### a) 通用寄存器有哪些？段的概念和CS、DS、SS的作用如何？CPU是如何从内存取到指令的？CS、IP（汇编语言书第二章）

- 通用寄存器包括ax bx cx dx

- 段的概念: 段的划分来自于CPU, 由于8086用"基础地址(段地址*16)+偏移地址=物理地址"的方式给出内存单元的物理地址,使得我们可以用分段的方式来管理内存.

- CS是代码段寄存器, DS是数据段寄存器, SS是栈段寄存器

- 在任意时刻,设CS寄存器中的内容是M, IP中的内容是N, 那么8086CPU将从内存M*16+N单元开始, 读取一条指令执行

#### b) 假设a)取到的是MOV指令，如何在寄存器到寄存器，寄存器到内存，内存到寄存器之间“复制”数据。能否实现内存到内存的“复制“数据？（汇编语言书第三章）

- 从寄存器到内存或者从内存到寄存器复制数据, 都要首先计算出在内存中存取数据的实际物理地址, 然后通过地址总线传输数据

- 不能实现从内存到内存直接复制数据, 要通过通用寄存器中转

#### c) 程序地址、段和链接的概念。（汇编语言书第四章）

- 程序地址: 程序段的地址

- 段: 见a)

- 链接:
    - 当源程序很大时, 可以将它分为多个源程序文件来编译, 每个源程序编译成目标文件后, 再用链接程序将它们连接到一起,生成一个可执行文件.
    - 程序中调用了某个库文件中的子程序, 需要将这个库文件和该程序生成的目标文件链接到一起, 生成一个可执行文件
    - 一个源程序编译后, 得到了存有机器码的目标文件, 目标文件中的有些内容还不能直接用来生成可执行文件, 链接程序将这些内容处理为最终的可执行信息.

#### d) 假设a)取到的是IN、OUT指令，请解释能实现哪些功能？包括端口和控制器的概念。（汇编语言第12－15章）

- in指令表示将某个数据写入到某个地址的端口中. 而所谓的端口就是以下各种芯片中的寄存器:
    - 各种接口卡(比如,网卡\显卡)上的接口芯片, 它们控制接口卡进行工作
    - 主板上的接口芯片, CPU通过它们对部分外设进行访问
    - 其他芯片, 用来存储相关的系统信息, 或进行相关的输入输出处理

- out指令表示将某个地址的端口中的数据读到某个通用寄存器中去

#### e) 假设a)取到的是INT指令，请解释异常、中断的概念及其作用。（汇编语言第12－15章）

- 实际上,异常和中断的概念之间没有很本质或者很明显的划分,感觉其名称更像是为了标明CPU处理指令序列时发生的"中断"是从何处来的,将要执行怎样的操作来处理.比如在<深入理解计算机系统>一书中就将"中断"归类为"异常"的一种.

- 狭义上的异常又叫做内中断,一般时CPU在执行指令中引起的,比如:
    - 除法错误,比如,执行div指令产生的出发溢出
    - 单步执行
    - 执行into指令
    - 执行int指令

- 狭义上的中断又叫做外中断. 这种中断信息来自于CPU外部,当CPU外部只有需要处理的事情发生的时候,比如说,外设的输入达到,相关新品啊将向CPU发出相应的中断信息. CPU在执行当前指令后,可以检测到发送过来的中断信息, 引发中断过程, 处理外设的输入.

## 二、单CPU模式单任务多函数

> 理解函数与函数的作用过程及栈的作用。

### 2.（函数调函数的过程及栈变化）假设内存加载了一个有两个函数的程序，一个是主函数A，它会call另一个函数B，请解释调用和被调用函数间，是如何实现参数传递的？另外，栈里面还存储哪些内容呢？被调函数B运行完成后，是如何返回到函数A中的？（汇编语言书第9、10章）

#### a) call XXX  XXX是指什么？ call 和 jmp 的区别是什么？

- XXX是将要跳转的目的地址. 这个地址可能存储在立即数中\寄存器中\内存单元中

- jmp指令是无条件的直接跳转,即仅更改CS和IP的值; 而call指令包含jmp指令,执行call指令的时候,会首先根据是长跳转还是短跳转来将IP或CS和IP入栈,然后再执行jmp指令.

#### b) 栈及栈帧用哪几个寄存器表示？SS：SP   SS：BP（汇编语言书第10章）

- 一共需要3个寄存器 SS SP BP

- 其中,SS:SP指向栈帧的栈顶, SS:BP指向栈帧的基地址

#### c) 尝试描述调用过程中栈的过程。（汇编语言书第10章）

- 主函数A在执行call指令调用函数B之前,首先会把部分寄存器压栈,防止被B函数破坏,然后把B函数需要的参数依次压栈

- 执行call指令,把当前CS和IP寄存器的值压栈,然后设置CS和IP为将要跳转的目的地址

- 开始执行函数B,执行主要指令序列结束后,执行ret指令,将之前压入栈中的CS和IP从栈中弹出,即恢复执行函数B之前的CS和IP的值

- CPU的控制权回到主函数A,继续执行主函数A接下来的指令序列

### 3. （函数中产生异常处理的过程及栈变化）假设内存加载了一个有两个函数的程序，一个是主函数A，另一个是异常处理函数B，A会通过INT指令，激活异常处理函数B的执行，请解释主函数A和异常处理函数B间，能实现参数传递的吗？如何实现？另外，两个函数共用一个栈可以吗？为什么？（汇编语言书第12、13章）

- 当然能传递参数,主函数A可以选择把参数就放到通用寄存器上,也可以选择把参数压入栈中,供异常处理函数B来寻址使用.

- 这两个函数当然可以共用一个栈,因为这种情况下是执行完B再返回去执行A,执行完B后,栈中跟B相关的东西就没有意义了,所以可以被覆盖\修改等,所以可以共用一个栈.

### 4. （函数中产生硬件中断的处理过程栈变化）假设内存加载了一个有两个函数的程序，一个是主函数A，另一个是键盘中断函数B，请解释主函数A和中断处理函数B间，能实现参数传递的吗？如何实现？另外，两个函数共用一个栈可以吗？为什么？（汇编语言书第14、15章）

- 当然能传递参数,主函数A可以选择把参数就放到通用寄存器上,也可以选择把参数压入栈中,供中断处理函数B来寻址使用.

- 这两个函数当然可以共用一个栈,因为这种情况下是执行完B再返回去执行A,执行完B后,栈中跟B相关的东西就没有意义了,所以可以被覆盖\修改等,所以可以共用一个栈.

### 5. （键盘中断驱动下的两函数交替运行）假设内存加载了一个有三个函数的程序，分别是函数A、B，还有一个是键盘中断函数C，键盘按下A时，运行函数A，键盘按下B时，运行函数B。请描述如何实现这一功能？（假设键盘按得慢，每次运行A和B时不会被下一次按键打断）三个函数共用一个栈可以吗？为什么？需要至少需要几个栈？每个函数用一个栈可以吗？为什么？

- 编写好函数A B C,然后在需要的情况下相互调用就好. 在主函数运行时,如果键盘中有一个键被按下,那将中断现在正在执行的主函数,跳转执行键盘中断函数C,然后C根据按下键的值的不同,去调用不同的函数A或函数B.

- 这三个函数可以共用一个栈. 在函数嵌套调用过程中栈不断往上生长就行,执行完一个函数后通过iret指令就能返回到调用者的调用函数时的现场.

## 三、单CPU模式多（线程）任务

理解函数作为线程运行的过程，线程的创建、中止及切换。

### 6. （时钟中断驱动下的两函数交叉运行）假设内存加载了一个有三个函数的程序，分别是函数A、B（每个可至少运行100秒以上），还有一个是时钟中断处理函数C，硬件时钟每毫秒产生一次中断，中断处理函数C返回时，轮流切换函数A、B的运行。请描述，如何实现这一功能？三个函数共用一个栈可以吗？为什么？需要至少需要几个栈？每个函数用一个栈可以吗？为什么？

这三个函数不能共用一个栈.至少要两个栈.

如果共用一个栈的话,假设在A执行但还没有结束的时候,要切换到函数B执行.如果共用一个栈的话,函数B的栈帧就要接着在A函数的栈上向上生长.接着,如果在B函数还没有结束的时候,又切换回A函数执行,这时A函数的栈帧也要接着向上增长,这样就会破坏函数B的栈帧,导致再次切换回B的时候产生错误.所以至少要使用两个栈.

由于函数C是中断处理函数,所以在执行函数C的时候不会再次发生中断,因此不用考虑保留函数C的执行状态,函数C完全可以与A函数或B函数共用一个栈.

### 7. （两函数的运行切换）上面第6题中，C函数需要知道函数A、B的入口地址或上次停止的地址，它怎么知道呢？尝试描述一下，如何表示这些信息，并描述一下从函数A中发生中断，运行C，然后切换到B的运行过程。

在第6题中我们知道,每个AB函数都对应一个栈,因此每个函数都有自己的`ss:sp`,每个函数也都有自己的指令执行序列,因此每个函数都有自己的`cs:ip`.从函数A中发生中断，运行C，然后切换到B的运行过程应该是这样的:

- 函数A收到中断信号,将自己当前的cs\ip\通用寄存器\标志寄存器等都压入栈中,同时,将自己当前的栈指针ss和sp存入自己的TCB中保存起来.

- 接着,A函数会去查找中断向量表,找到函数C的cs和ip,然后执行函数C的代码

- 函数C会选择执行A还是执行B,如果执行B的话,函数C会找到B的TCB,从中取出B的ss和sp,把自己的ss和sp置换为B的ss和sp,完成栈的切换

- 接着,函数C执行iret指令返回,该指令会把当前栈(现在已经是B的栈了)中保存的cs\ip\通用寄存器\标志寄存器等恢复出来(这些寄存器的值都是当初B中断的时候压入栈中的),这样cs和ip就会指向B的代码,其他寄存器也恢复到了从B中切换出去的时候的样子.

### 8. （线程的概念）你觉得第6、7中的两个函数A、B能够轮流运行，它们是两个线程吗？为什么？尝试描述一下你所理解的线程的概念是什么。

- 它们是两个线程.因为它们可以被调度,符合线程的条件.

- 我理解的线程: 可以被CPU调度的最小单位,有自己独立的运行栈,但数据段\代码段等都可以和其他线程共享.

### 9. 有了线程的概念后，我们就有需要把D函数、E函数等也创建成线程。要把一个普通函数创建成线程，需要做哪些事情呢？TCB有哪些内容？尝试描述并实现一个create_thread?

- 要把一个普通函数创建为线程,要在内存中要分割出一块空间作为该线程的TCB,然后给该线程分配一个唯一的线程号,保存在系统的线程表中.

- 一个TCB中必须应该包括的内容:
    - 线程的运行状态,标明线程是运行\就绪\阻塞
    - 线程使用的运行时栈的栈指针

- 一个TCB中还可以包含的内容,如果是基于栈的线程切换的话,下面这些内容也可以直接压入线程的运行时栈中:
    - 线程的cs和ip寄存器
    - 线程的标志寄存器
    - 线程的通用寄存器(存放必要的参数等)

### 10. 如果想终止一个线程，需要做哪些事情呢？尝试描述并实现一个cancel_thread?

如果要终止一个线程,只需要把线程对应的TCB块的内存释放,然后从系统的线程表中删除该线程的线程号.

### 11. 如果我们有一个线程A（函数A）和线程B（函数B）的协作需求，必须在A执行过A函数的S1语句后，B才能执行B函数的S2语句，这就是同步。实现同步，实际上就是当运行到S2时检查一下S1运行过没有；如果运行过了，就继续，如果没有，就阻塞住线程B的运行。阻塞的方式有两种，一种是让它空转并所得查看S1，一种是让它睡眠等待S1执行过后的唤醒。临界区、锁、关中断、互斥量、信号量、条件变量等概念及其实现。

#### 临界区

进程要进行修改公共变量\更新一个表\写一个文件等操作的代码区.

#### 锁

锁是解决临界区问题的一种机制. 当一个进程进入临界区的时候, 会获得锁, 给临界区上锁, 这样其他进程就不能访问该临界区的公共变量了. 当进程退出临界区的时候会释放锁,  这时其他进程将可以修改临界区中的公共变量.

#### 关中断

- 如果CPU在执行某一段指令之前关闭中断,就表示该CPU在执行这段指令的过程中不会响应中断,这几个指令就相当于是原子操作.

- 可以使用在进入临界区之前关中断的方法来使对变量的修改变成原子操作,从而达到互斥的目的.

#### 互斥量

- 互斥量其实就是互斥锁.它用于实现关于只有一个实例的共享资源的同步和互斥.

- 锁是解决临界区问题的一种机制. 当一个进程进入临界区的时候, 会获得锁, 给临界区上锁, 这样其他进程就不能访问该临界区的公共变量了. 当进程退出临界区的时候会释放锁,  这时其他进程将可以修改临界区中的公共变量.

#### 信号量

信号量可以分为二值信号量和计数信号量. 其中二值信号量与互斥锁的作用基本相同. 而计数信号量可以表达更多的信息, 它可以用于控制访问具有多个实例的资源. 信号量的初值一般是可用资源数量, 而某一刻信号量的值则表示还有多少个实例可以被其余进程占用. 如果信号量为负值, 则可以表示有多少个进程再等待使用该资源.

#### 条件变量

我的理解是,条件变量可以看做是信号量的一种延伸, 它与信号量不同的是, 条件变量一般用于线程之间,信号量一般用于进程之间.它可以有这样一个数据结构:一个变量和一个等待队列. 变量的大小和范围表示某种条件,不满足该条件的进程将会被加入到等待队列,满足该条件时队列中的进程会被唤醒,变成就绪态.

> 目前为止，每个线程都可以调用create_thread创建线程，每个线程都可以直接IO操作，都可以设置时钟中断的时长，如果它恶意的修改了中断处理函数用来决定切换顺序的数据结构，那么就会影响整个系统的运行。程序空间就是物理空间。

> 把开关中断，IO指令、时钟周期的设置等等涉及到整个计算机系统运行情况的CPU指令作为特权指令，只让服务于整个系统的函数才能使用，其他普通线程函数都只能使用这些指令以外的普通指令。

> 这样把CPU设计开两种运行模式（系统模式和用户模式）。系统模式下能够运行CPU所有指令，用户模式下，只能够运行CPU普通指令。

> 在CPU双模式下，把创建线程、中止线程，创建信号量、PV操作、开关中断，IO指令、I异常和中断处理函数等涉及到多个线程和整个系统相关的函数，与普通线程的函数区别开来（作为OS的雏形）

> 作为OS雏形的部分（包括C函数），放置在内核空间，作为多线程的A、B函数，放置在用户空间。

## 双CPU模式单进程空间

> 理解进程空间由用户空间和内核空间组成。理解基于386如何搭建出一个进程空间。用户程序对过分段到线性空间的用户空间部分，内核程序通过分段映射到线性空间的内核空间部分。线性空间就是物理空间。

### 12. 在386启动过程中，将CR0寄存器的保护模式位置位，也就是启用保护模式，使386CPU具备了0-3四个运行级别。操作系统里说的CPU双模式，指的是386里的0和3两个运行级别。0级别是系统模式，3级别是用户模式。请说说386设置4个运行级别的目的是什么？为什么操作系统只用了两个运行级别（双模式）？

- 386设置4个运行级别的目的是为了防止运行在较低特权级上的程序或任务访问具有较高特权级的段.

- 操作系统只是用了两个运行级别的原因: 为了与只提供了两个特权级的处理器兼容.

### 13. 分段的作用，是通过段表，把一个程序中的多个段映射到一维的线性空间（4GB）。为便于理解，本部分下面的几个问题都假设计算机正好也有4GB的物理内存，这样4GB的线性空间正好能一对一装载到物理空间。

### 14. CS：EIP是386CPU给出的PC（程序地址），DS：EXX是数据地址，SS：ESP是栈地址，SS：EBP是栈帧地址。试描述一下CS、DS、SS和GDTR、LDTR的关系。GDT、LDT里面存储的都是段描述符，有什么区别吗？

#### CS、DS、SS和GDTR、LDTR的关系

- GDTR和LDTR都是中分别存放着GDT表和LDT表的基地址和表长度

- CS\DS\SS都是段寄存器,分为两部分,可见部分和不可见部分
    - 可见部分存放着段选择符,该段选择符是其所指向的段描述符在GDT表或LDT表中的偏移位置,也就是说,GDTR或LDTR中的表基地址加上段选择符,就可以获取到段描述符,而从段描述符中就可以找到段的基地址.
    - 不可见部分一般存放着段描述符的一些基本信息.这样程序在执行的时候就不用每次都去查找LDT表了,可以节约时间提高效率.

### 15. 现在假设一个执行文件里保存了内核的代码段和数据段，一个执行文件里保存了用户空间的代码段和数据段。我们直接把这四个段装载到物理内存，可能会存在什么问题？

如果没有附加段机制或者分页机制这些保护措施的话,可能会导致用户程序修改内核的代码或者数据,从而引发错误.

### 16. 还是假设第15 题中的两个可执行文件，我们想把内核的段映射到内核空间（CPL、DPL为0），把用户的段映射到用户空间（CPL、DPL为3），直接在GDT里创建四段描述符，可以吗？在GDT里创建内核两个段的描述符，再创建一个LDT的描述符；然后在LDT里再创建两个用户段的描述符，也是一种方案。这两种方案各有什么优缺点？

- 这两种方案都是可行的

- 直接在GDT表中创建内核的两个段的描述符
    - 可以简化从逻辑地址到线性地址的地址转化操作,应用程序只需要一个GDTR寄存器即可.
    - 减少内存空间的开销

- 在GDT里创建内核两个段的描述符，再创建一个LDT的描述符；然后在LDT里再创建两个用户段的描述符
    - 方便实现多个用户任务对线性空间的隔离和映射,每个用户任务只能使用自己的LDTR来访问自己的LDT表,无法访问其他用户任务的LDT表
    - 当然,本题中讨论的是只有一个内核段和一个用户段,所以实际上不存在多个用户任务互相访问对方的LDT表的情况

### 17. 当然，为了让内核空间的程序和用户空间的程序能够运行，我们需要分别在内核空间和用户空间各创建一个栈段，也就是要在GDT、LDT增加两个段描述符。试基于16题里的两种方案分别讲讲在哪里增加。

- 直接在GDT表中创建内核的两个段的描述符
    - 不管是用户空间还是内核空间,都直接是直接在GDT表中增加一个段描述符,不过要注意内核的段和用户的段描述符要设置不同的DPL

- 在GDT里创建内核两个段的描述符，再创建一个LDT的描述符；然后在LDT里再创建两个用户段的描述符
    - 要在内核空间创建一个栈段的话,只需要在GDT表中增加一个段描述符
    - 要在用户空间创建一个栈段的话,需要在该用户任务对应的LDT表中增加一个段描述符
 
> 有了386的0，3运行级别，以及GDT和LDT的初始化后。下面我们再回头看看第二部分和第三部分的各题目的故事，有了哪些变化。
